[
  {
    "id": "art_001",
    "title": "Vue 3 Composition API 完全指南：从入门到精通",
    "summary": "深入探讨 Vue 3 Composition API 的核心概念、使用场景和最佳实践。通过实际案例帮助你理解如何用 Composition API 编写更优雅、更易维护的代码。",
    "content": "# Vue 3 Composition API 完全指南\n\n## 什么是 Composition API？\n\nComposition API 是 Vue 3 中新增的一组 API，它提供了一种更灵活的方式来组织组件逻辑。相比于 Options API，Composition API 能够更好地实现逻辑复用和代码组织。\n\n## 核心概念\n\n### 1. setup 函数\n\n`setup` 是 Composition API 的入口点，它在组件创建之前执行，接收 `props` 和 `context` 两个参数。\n\n```javascript\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n    const increment = () => count.value++\n    \n    return {\n      count,\n      increment\n    }\n  }\n}\n```\n\n### 2. 响应式引用 ref\n\n`ref` 用于创建响应式的基本类型数据。\n\n```javascript\nimport { ref } from 'vue'\n\nconst count = ref(0)\nconsole.log(count.value) // 0\n\ncount.value++\nconsole.log(count.value) // 1\n```\n\n### 3. 响应式对象 reactive\n\n`reactive` 用于创建响应式的对象。\n\n```javascript\nimport { reactive } from 'vue'\n\nconst state = reactive({\n  count: 0,\n  message: 'Hello'\n})\n\nstate.count++ // 响应式更新\n```\n\n## 最佳实践\n\n1. **逻辑复用**：使用组合式函数（Composables）\n2. **代码组织**：按功能而非选项组织代码\n3. **类型安全**：结合 TypeScript 使用\n\n## 总结\n\nComposition API 为 Vue 3 带来了更强大的逻辑复用能力和更好的 TypeScript 支持，是现代 Vue 开发的推荐方式。",
    "cover": "https://images.unsplash.com/photo-1633356122544-f134324a6cee?w=800",
    "category": "vue",
    "tags": ["Vue 3", "Composition API", "响应式", "最佳实践"],
    "author": {
      "id": "author_001",
      "name": "前端小智",
      "avatar": "https://api.dicebear.com/7.x/avataaars/svg?seed=Felix",
      "bio": "Vue.js 核心团队成员"
    },
    "publishTime": "2024-01-15T10:30:00Z",
    "updateTime": "2024-01-20T14:20:00Z",
    "views": 15234,
    "likes": 892,
    "comments": 156,
    "collections": 445,
    "readingTime": 8,
    "isTop": true,
    "isFeatured": true
  },
  {
    "id": "art_002",
    "title": "React Hooks 深度解析：useState 和 useEffect 的底层原理",
    "summary": "深入剖析 React Hooks 的实现原理，理解 useState 和 useEffect 背后的机制，掌握 Hooks 的正确使用方式。",
    "content": "# React Hooks 深度解析\n\n## Hooks 的设计动机\n\nReact Hooks 的出现解决了类组件的几个痛点：\n\n1. 难以复用状态逻辑\n2. 复杂组件难以理解\n3. class 组件的 this 指向问题\n\n## useState 原理\n\n```javascript\nfunction useState(initialValue) {\n  const [state, setState] = React.useState(initialValue)\n  \n  // 内部维护一个状态数组和索引\n  return [state, setState]\n}\n```\n\n### 核心实现\n\n```javascript\nlet state = []\nlet setters = []\nlet cursor = 0\n\nfunction createSetter(cursor) {\n  return function setter(newVal) {\n    state[cursor] = newVal\n  }\n}\n\nexport function useState(initVal) {\n  state[cursor] = state[cursor] || initVal\n  setters[cursor] = setters[cursor] || createSetter(cursor)\n  const setter = setters[cursor]\n  const value = state[cursor]\n  cursor++\n  return [value, setter]\n}\n```\n\n## useEffect 原理\n\n```javascript\nfunction useEffect(callback, deps) {\n  const hasChanged = !prevDeps || \n    deps.some((dep, i) => dep !== prevDeps[i])\n    \n  if (hasChanged) {\n    callback()\n  }\n  \n  prevDeps = deps\n}\n```\n\n## 最佳实践\n\n1. **依赖数组**：始终正确声明依赖\n2. **自定义 Hooks**：封装复用逻辑\n3. **避免过度优化**：合理使用 useMemo 和 useCallback\n\n## 总结\n\n理解 Hooks 的原理有助于我们更好地使用它们，避免常见的陷阱。",
    "cover": "https://images.unsplash.com/photo-1633356122102-3fe601e05bd2?w=800",
    "category": "react",
    "tags": ["React", "Hooks", "useState", "useEffect", "源码解析"],
    "author": {
      "id": "author_002",
      "name": "React 大师",
      "avatar": "https://api.dicebear.com/7.x/avataaars/svg?seed=Aneka",
      "bio": "专注 React 生态"
    },
    "publishTime": "2024-01-18T09:00:00Z",
    "updateTime": "2024-01-18T09:00:00Z",
    "views": 12456,
    "likes": 756,
    "comments": 98,
    "collections": 389,
    "readingTime": 10,
    "isTop": false,
    "isFeatured": true
  },
  {
    "id": "art_003",
    "title": "JavaScript 异步编程完全指南：从回调到 Async/Await",
    "summary": "全面讲解 JavaScript 异步编程的演进历程，从回调地狱到 Promise，再到 async/await，帮你彻底理解异步编程。",
    "content": "# JavaScript 异步编程完全指南\n\n## 异步编程的演进\n\n### 1. 回调函数（Callbacks）\n\n```javascript\nfunction fetchData(callback) {\n  setTimeout(() => {\n    callback('数据')\n  }, 1000)\n}\n\nfetchData((data) => {\n  console.log(data)\n})\n```\n\n**问题**：回调地狱（Callback Hell）\n\n### 2. Promise\n\n```javascript\nfunction fetchData() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve('数据')\n    }, 1000)\n  })\n}\n\nfetchData()\n  .then(data => console.log(data))\n  .catch(error => console.error(error))\n```\n\n### 3. Async/Await\n\n```javascript\nasync function getData() {\n  try {\n    const data = await fetchData()\n    console.log(data)\n  } catch (error) {\n    console.error(error)\n  }\n}\n```\n\n## Promise 详解\n\n### Promise 的三种状态\n\n1. **Pending**（进行中）\n2. **Fulfilled**（已成功）\n3. **Rejected**（已失败）\n\n### Promise 链式调用\n\n```javascript\nfetch('/api/user')\n  .then(response => response.json())\n  .then(user => fetch(`/api/posts/${user.id}`))\n  .then(response => response.json())\n  .then(posts => console.log(posts))\n  .catch(error => console.error(error))\n```\n\n## Async/Await 最佳实践\n\n### 1. 错误处理\n\n```javascript\nasync function fetchUserData() {\n  try {\n    const response = await fetch('/api/user')\n    const data = await response.json()\n    return data\n  } catch (error) {\n    console.error('获取数据失败:', error)\n    throw error\n  }\n}\n```\n\n### 2. 并发请求\n\n```javascript\n// 串行执行（慢）\nconst user = await fetchUser()\nconst posts = await fetchPosts()\n\n// 并发执行（快）\nconst [user, posts] = await Promise.all([\n  fetchUser(),\n  fetchPosts()\n])\n```\n\n## 总结\n\nAsync/Await 是目前最优雅的异步编程方式，但理解 Promise 的原理同样重要。",
    "cover": "https://images.unsplash.com/photo-1579468118864-1b9ea3c0db4a?w=800",
    "category": "javascript",
    "tags": ["JavaScript", "异步编程", "Promise", "async/await", "ES6+"],
    "author": {
      "id": "author_003",
      "name": "JS 探索者",
      "avatar": "https://api.dicebear.com/7.x/avataaars/svg?seed=Charlie",
      "bio": "JavaScript 语言专家"
    },
    "publishTime": "2024-01-20T14:30:00Z",
    "updateTime": "2024-01-22T10:15:00Z",
    "views": 18945,
    "likes": 1024,
    "comments": 203,
    "collections": 567,
    "readingTime": 12,
    "isTop": true,
    "isFeatured": true
  },
  {
    "id": "art_004",
    "title": "TypeScript 类型体操：高级类型与泛型实战",
    "summary": "深入学习 TypeScript 的高级类型系统，掌握泛型、映射类型、条件类型等高级特性，提升代码的类型安全性。",
    "content": "# TypeScript 类型体操\n\n## 泛型基础\n\n### 1. 泛型函数\n\n```typescript\nfunction identity<T>(arg: T): T {\n  return arg\n}\n\nconst result = identity<string>('hello')\n```\n\n### 2. 泛型接口\n\n```typescript\ninterface GenericInterface<T> {\n  value: T\n  getValue(): T\n}\n\nconst obj: GenericInterface<number> = {\n  value: 42,\n  getValue() {\n    return this.value\n  }\n}\n```\n\n## 高级类型\n\n### 1. 映射类型（Mapped Types）\n\n```typescript\ntype Readonly<T> = {\n  readonly [P in keyof T]: T[P]\n}\n\ntype Partial<T> = {\n  [P in keyof T]?: T[P]\n}\n```\n\n### 2. 条件类型（Conditional Types）\n\n```typescript\ntype NonNullable<T> = T extends null | undefined ? never : T\n\ntype Example = NonNullable<string | null> // string\n```\n\n### 3. 工具类型\n\n```typescript\n// Pick - 选取部分属性\ntype User = {\n  id: number\n  name: string\n  email: string\n}\n\ntype UserPreview = Pick<User, 'id' | 'name'>\n\n// Omit - 排除部分属性\ntype UserWithoutEmail = Omit<User, 'email'>\n\n// Record - 创建对象类型\ntype PageInfo = Record<'home' | 'about', { title: string }>\n```\n\n## 实战案例\n\n### 类型安全的 API 请求\n\n```typescript\ninterface ApiResponse<T> {\n  data: T\n  status: number\n  message: string\n}\n\nasync function request<T>(url: string): Promise<ApiResponse<T>> {\n  const response = await fetch(url)\n  return response.json()\n}\n\ninterface User {\n  id: number\n  name: string\n}\n\nconst userResponse = await request<User>('/api/user')\nconsole.log(userResponse.data.name) // 类型安全\n```\n\n## 总结\n\n掌握 TypeScript 的高级类型系统能够显著提升代码质量和开发效率。",
    "cover": "https://images.unsplash.com/photo-1516116216624-53e697fedbea?w=800",
    "category": "typescript",
    "tags": ["TypeScript", "泛型", "类型系统", "高级类型", "最佳实践"],
    "author": {
      "id": "author_004",
      "name": "类型大师",
      "avatar": "https://api.dicebear.com/7.x/avataaars/svg?seed=Dusty",
      "bio": "TypeScript 布道师"
    },
    "publishTime": "2024-01-22T11:00:00Z",
    "updateTime": "2024-01-22T11:00:00Z",
    "views": 9876,
    "likes": 623,
    "comments": 87,
    "collections": 312,
    "readingTime": 15,
    "isTop": false,
    "isFeatured": true
  },
  {
    "id": "art_005",
    "title": "CSS Grid 布局完全指南：从基础到高级",
    "summary": "全面介绍 CSS Grid 布局系统，从基本概念到高级技巧，帮助你掌握现代网页布局的强大工具。",
    "content": "# CSS Grid 布局完全指南\n\n## 基础概念\n\n### Grid 容器和项目\n\n```css\n.container {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  grid-gap: 20px;\n}\n```\n\n## 核心属性\n\n### 1. 定义网格\n\n```css\n.container {\n  display: grid;\n  \n  /* 列定义 */\n  grid-template-columns: 200px 1fr 2fr;\n  \n  /* 行定义 */\n  grid-template-rows: 100px auto 100px;\n  \n  /* 间距 */\n  gap: 20px;\n}\n```\n\n### 2. 网格项目定位\n\n```css\n.item {\n  /* 跨越列 */\n  grid-column: 1 / 3;\n  \n  /* 跨越行 */\n  grid-row: 1 / 2;\n  \n  /* 简写 */\n  grid-area: 1 / 1 / 2 / 3;\n}\n```\n\n## 高级技巧\n\n### 1. 命名网格线\n\n```css\n.container {\n  grid-template-columns: [start] 1fr [middle] 1fr [end];\n}\n\n.item {\n  grid-column: start / middle;\n}\n```\n\n### 2. Grid Areas\n\n```css\n.container {\n  grid-template-areas:\n    \"header header header\"\n    \"sidebar content content\"\n    \"footer footer footer\";\n}\n\n.header { grid-area: header; }\n.sidebar { grid-area: sidebar; }\n.content { grid-area: content; }\n.footer { grid-area: footer; }\n```\n\n### 3. 自动填充\n\n```css\n.container {\n  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n}\n```\n\n## 实战案例\n\n### 响应式画廊布局\n\n```css\n.gallery {\n  display: grid;\n  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));\n  gap: 1rem;\n  padding: 1rem;\n}\n\n.gallery-item {\n  aspect-ratio: 1;\n  overflow: hidden;\n}\n\n.gallery-item:nth-child(3n) {\n  grid-column: span 2;\n  grid-row: span 2;\n}\n```\n\n## 总结\n\nCSS Grid 是现代布局的首选方案，配合 Flexbox 可以轻松实现各种复杂布局。",
    "cover": "https://images.unsplash.com/photo-1507721999472-8ed4421c4af2?w=800",
    "category": "css",
    "tags": ["CSS", "Grid布局", "响应式设计", "布局技巧"],
    "author": {
      "id": "author_005",
      "name": "CSS 魔法师",
      "avatar": "https://api.dicebear.com/7.x/avataaars/svg?seed=Emma",
      "bio": "CSS 布局专家"
    },
    "publishTime": "2024-01-25T16:00:00Z",
    "updateTime": "2024-01-25T16:00:00Z",
    "views": 7654,
    "likes": 445,
    "comments": 56,
    "collections": 234,
    "readingTime": 9,
    "isTop": false,
    "isFeatured": false
  }
]
